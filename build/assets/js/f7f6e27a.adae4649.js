"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[592],{3905:(e,t,r)=>{r.d(t,{Zo:()=>d,kt:()=>m});var n=r(7294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function i(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function o(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?i(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):i(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},i=Object.keys(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var l=n.createContext({}),c=function(e){var t=n.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):o(o({},t),e)),r},d=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),p=c(r),h=a,m=p["".concat(l,".").concat(h)]||p[h]||u[h]||i;return r?n.createElement(m,o(o({ref:t},d),{},{components:r})):n.createElement(m,o({ref:t},d))}));function m(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=r.length,o=new Array(i);o[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[p]="string"==typeof e?e:a,o[1]=s;for(var c=2;c<i;c++)o[c]=r[c];return n.createElement.apply(null,o)}return n.createElement.apply(null,r)}h.displayName="MDXCreateElement"},1496:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var n=r(7462),a=(r(7294),r(3905));const i={title:"SVD Bindings",description:"Implementation of SVD Bindings.",sidebar_position:4},o=void 0,s={unversionedId:"low-level-architecture/svd",id:"low-level-architecture/svd",title:"SVD Bindings",description:"Implementation of SVD Bindings.",source:"@site/docs/low-level-architecture/svd.md",sourceDirName:"low-level-architecture",slug:"/low-level-architecture/svd",permalink:"/docs/low-level-architecture/svd",draft:!1,editUrl:"https://github.com/scsd-cdh/docs/tree/main/docs/low-level-architecture/svd.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{title:"SVD Bindings",description:"Implementation of SVD Bindings.",sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"Hardware Abstraction Layer",permalink:"/docs/low-level-architecture/hal"},next:{title:"Configuration Crate",permalink:"/docs/low-level-architecture/config"}},l={},c=[{value:"CMSIS-SVD",id:"cmsis-svd",level:2},{value:"svd2ada",id:"svd2ada",level:2},{value:"What is it?",id:"what-is-it",level:3},{value:"Where can I get CMSIS-SVD files?",id:"where-can-i-get-cmsis-svd-files",level:3},{value:"How can I use svd2ada?",id:"how-can-i-use-svd2ada",level:3}],d={toc:c},p="wrapper";function u(e){let{components:t,...r}=e;return(0,a.kt)(p,(0,n.Z)({},d,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"The SVD Bindings is a crate which provides Ada bindings generated from CMSIS-SVD descriptions for ARM Cortex-M MCUs. It is a crate which is optional, meaning instead of creating drivers from the SVD bindings, it is possible to implement the HAL by linking a vendor-specific library which already implements the functionality for each drivers. As an example, Microchip provides the Atmel Software Framework 4 (ASF4), which we could link to our crate and call the functions that are provided by the framework. However, to streamline the process, we can choose to implement these drivers ourselves. This way whenever we need to add support to implement support for a new MCU, there won't be a need to learn a brand new framework everytime, we can just do the same process for each MCUs no matter who the vendor is. Starting from scratch however would be a very big undertaking which would require a lot of research and refering to the MCU's users guide which are typically very large documents that are easy to get lost in."),(0,a.kt)("h2",{id:"cmsis-svd"},"CMSIS-SVD"),(0,a.kt)("p",null,"Relying on CMSIS-SVD has the following benefits:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Consistency between the header files and what is displayed by the debugger."),(0,a.kt)("li",{parentName:"ul"},"Detailed information about peripherals, registers, fields and bit values."),(0,a.kt)("li",{parentName:"ul"},"Detailed information about the interrupts."),(0,a.kt)("li",{parentName:"ul"},"Improved software development efficiency.")),(0,a.kt)("h2",{id:"svd2ada"},"svd2ada"),(0,a.kt)("h3",{id:"what-is-it"},"What is it?"),(0,a.kt)("p",null,"It is an open-source program which takes in a CMSIS-SVD definition and outputs .ads files containing the necessary types and packages to implement the drivers. It can be found in ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/AdaCore/svd2ada"},"this repository"),"."),(0,a.kt)("h3",{id:"where-can-i-get-cmsis-svd-files"},"Where can I get CMSIS-SVD files?"),(0,a.kt)("p",null,"For most MCUs, you will be able to find the SVD file within the CMSIS-Pack for the MCU you are implementing the drivers for ",(0,a.kt)("a",{parentName:"p",href:"https://keil.arm.com/packs"},"here"),"."),(0,a.kt)("h3",{id:"how-can-i-use-svd2ada"},"How can I use svd2ada?"),(0,a.kt)("p",null,"Here is an example of how to generate the files using svd2ada:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"svd2ada \\                                   # The command-line tool\n    ../svd/ATSAMV71Q21B.svd \\               # The input SVD file\n    --boolean \\                             # Represent single-bit fields as Booleans\n    -o src \\                                # Output directory\n    -p SAM_SVD \\                            # The root package name for the generated spec hierarchy\n    --base-types-package HAL \\              # Use base types from the HAL package\n    --gen-uint-always \\                     # Generate UInt* for base types; do not use the Bit and Byte variants\n")))}u.isMDXComponent=!0}}]);