"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[944],{3905:(e,t,r)=>{r.d(t,{Zo:()=>d,kt:()=>h});var a=r(7294);function n(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function i(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,a)}return r}function o(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?i(Object(r),!0).forEach((function(t){n(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):i(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function l(e,t){if(null==e)return{};var r,a,n=function(e,t){if(null==e)return{};var r,a,n={},i=Object.keys(e);for(a=0;a<i.length;a++)r=i[a],t.indexOf(r)>=0||(n[r]=e[r]);return n}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)r=i[a],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(n[r]=e[r])}return n}var c=a.createContext({}),s=function(e){var t=a.useContext(c),r=t;return e&&(r="function"==typeof e?e(t):o(o({},t),e)),r},d=function(e){var t=s(e.components);return a.createElement(c.Provider,{value:t},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var r=e.components,n=e.mdxType,i=e.originalType,c=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),p=s(r),m=n,h=p["".concat(c,".").concat(m)]||p[m]||u[m]||i;return r?a.createElement(h,o(o({ref:t},d),{},{components:r})):a.createElement(h,o({ref:t},d))}));function h(e,t){var r=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var i=r.length,o=new Array(i);o[0]=m;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l[p]="string"==typeof e?e:n,o[1]=l;for(var s=2;s<i;s++)o[s]=r[s];return a.createElement.apply(null,o)}return a.createElement.apply(null,r)}m.displayName="MDXCreateElement"},3917:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>l,toc:()=>s});var a=r(7462),n=(r(7294),r(3905));const i={title:"Hardware Abstraction Layer",description:"Implementation of HALs.",sidebar_position:3},o="Hardware Abstraction Layer (HAL)",l={unversionedId:"low-level-architecture/hal",id:"low-level-architecture/hal",title:"Hardware Abstraction Layer",description:"Implementation of HALs.",source:"@site/docs/low-level-architecture/hal.md",sourceDirName:"low-level-architecture",slug:"/low-level-architecture/hal",permalink:"/docs/low-level-architecture/hal",draft:!1,editUrl:"https://github.com/scsd-cdh/docs/tree/main/docs/low-level-architecture/hal.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{title:"Hardware Abstraction Layer",description:"Implementation of HALs.",sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Board Support Packages",permalink:"/docs/low-level-architecture/bsp"},next:{title:"SVD Bindings",permalink:"/docs/low-level-architecture/svd"}},c={},s=[{value:"Introduction",id:"introduction",level:2},{value:"Creating a Hardware Abstraction Layer",id:"creating-a-hardware-abstraction-layer",level:2}],d={toc:s},p="wrapper";function u(e){let{components:t,...r}=e;return(0,n.kt)(p,(0,a.Z)({},d,r,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"hardware-abstraction-layer-hal"},"Hardware Abstraction Layer (HAL)"),(0,n.kt)("h2",{id:"introduction"},"Introduction"),(0,n.kt)("p",null,"The Hardware Abstraction Layer (HAL) is a crate which should provide the following:"),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},"Serial communication drivers"),(0,n.kt)("li",{parentName:"ol"},"GPIO drivers"),(0,n.kt)("li",{parentName:"ol"},"ADC/DAC drivers (if applicable)"),(0,n.kt)("li",{parentName:"ol"},"Clocks / Timers"),(0,n.kt)("li",{parentName:"ol"},"Hardware Interrupts")),(0,n.kt)("p",null,"Normally, a HAL would also provide the initialization code for the microcontroller. But, in our case, the Ada runtime for the MCU already provides it."),(0,n.kt)("p",null,"The HAL implementation should have a dependency on the ",(0,n.kt)("inlineCode",{parentName:"p"},"hal")," crate, which is already available in the community Alire index. This crate provides an interface that will need to be implemented for each of the microcontrollers we are using. To make this task easier, we will use the SVD bindings (see next section) that are generated by the svd2ada utility."),(0,n.kt)("h2",{id:"creating-a-hardware-abstraction-layer"},"Creating a Hardware Abstraction Layer"),(0,n.kt)("p",null,"Creating an hardware abstraction layer for the first time will be a challenging task. However there are many great resources to learn how to complete it. Here are a few of them:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/AdaCore/Ada_Drivers_Library"},"GitHub Repository for Ada_Drivers_Library")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://blog.adacore.com/starting-micro-controller-ada-drivers-in-the-alire-ecosystem"},"Starting micro-controller Ada drivers in the Alire ecosystem")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/dkm/stm32f0x2_hal-ada/tree/main/src/drivers"},"STM32F0X2 HAL Implementation"))))}u.isMDXComponent=!0}}]);